from mnms import tiled_noise as tn, mpi, utils, simio, simtest, tiled_ndmap as tnd
from soapack import interfaces as sints
from pixell import enmap, wcsutils
import argparse
import numpy as np
import time

# This script generates a noise simulation from the covariance and square-root covariance matrices
# generated by noise_gen.py
# It is a crossfade in harmonic space of a 1D global, isotropic sim at low well, and a 2D tiled sim at high ell
# It saves maps of single splits at a time, as in the typical ACT format, although map shapes
# are always (num_arrays, num_splits=1, num_pols, ny, nx

mm = mpi.TiledMPIManager()
parser = argparse.ArgumentParser()
parser.add_argument('--qid',dest='qid',nargs='+',type=str,required=True,help='list of soapack DR5 array "qids"')

# these arguments serve only to load correct covariance products
parser.add_argument('--no-bin-apod',dest='bin_apod',default=True,action='store_false',help='if passed, do not load default binary apodized mask')
parser.add_argument('--mask-version',dest='mask_version',type=str,default=None,help='if --no-bin-apod, look in dr6sims:mask_path/mask_version/ for mask (default: %(default)s)')
parser.add_argument('--mask-name', dest='mask_name',type=str,default=None,help='if --no-bin-apod, attempt to load dr6sims:mask_path/mask_version/mask_name.fits (default: %(default)s)')
parser.add_argument('--downgrade',dest='downgrade',type=int,default=1,help='downgrade all data in pixel space by square of this many pixels per side (default: %(default)s)')
parser.add_argument('--width-deg',dest='width_deg',type=float,default=4.0,help='width in degrees of central tile size (default: %(default)s)')
parser.add_argument('--height-deg',dest='height_deg',type=float,default=4.0,help='height in degrees of central tile size (default: %(default)s)')
parser.add_argument('--smooth-1d',dest='smooth_1d',type=int,default=5,help='width in ell to smooth 1D global, isotropic, power spectra (default: %(default)s)')
parser.add_argument('--delta-ell-smooth',dest='delta_ell_smooth',type=int,default=400,help='smooth 2D tiled power spectra by a square of this size in Fourier space (default: %(default)s)')
parser.add_argument('--notes',dest='notes',type=str,default=None,help='a simple notes string to manually distinguish this set of sims (default: %(default)s)')

# these arguments give parameters for the sims themselves
parser.add_argument('--ell-large-small-split',dest='ell_large_small_split',type=int,default=200,help='center of crossover point between 1D and 2D sims (default: %(default)s)')
parser.add_argument('--ell-taper-width',dest='ell_taper_width',type=int,default=200,help='width of linear transition between 1D and 2D sims (default: %(default)s)')
parser.add_argument('--no-auto-split',dest='auto_split',default=True,action='store_false',help='if passed, do not simulate every split for this array')
parser.add_argument('--split',nargs='+',dest='split',type=int,help='if --no-auto-split, simulate this list of splits (0-indexed) (default: %(default)s)')
parser.add_argument('--nsims',dest='nsims',type=int,default=None,help='make this many noise realizations for each split, with map_ids starting from previous highest map_id + 1 (default: %(default)s)')
parser.add_argument('--maps',dest='maps',nargs='+',type=str,default=None,help='simulate exactly these map_ids, overwriting if preexisting; overriden by --nsims (default: %(default)s)')
parser.add_argument('--maps-start',dest='maps_start',type=int,default=None,help='like --maps, except iterate starting at this map_id (default: %(default)s)')
parser.add_argument('--maps-end',dest='maps_end',type=int,default=None,help='like --maps, except end iteration with this map_id (default: %(default)s)')
parser.add_argument('--maps-step',dest='maps_step',type=int,default=1,help='like --maps, except step iteration over map_ids by this number (default: %(default)s)')

parser.add_argument('--data-model',dest='data_model',type=str,default='DR5',help='soapack DataModel class to use (default: %(default)s)')
args = parser.parse_args()

# get mask args
bin_apod = args.bin_apod
print(f'bin apod: {bin_apod}')
mask_version = args.mask_version or simio.default_mask
print(f'mask version: {mask_version}')
mask_name = args.mask_name
print(f'mask name: {mask_name}')

# Configuration parameters
ell_large_small_split = args.ell_large_small_split # Ell mode at which to switch to 2d noise spectrum
ell_taper_width = args.ell_taper_width # The width of the linear taper applied below above cut.

# Args for input spectra
width_deg = args.width_deg  
height_deg = args.height_deg
smooth_1d = args.smooth_1d
delta_ell_smooth = args.delta_ell_smooth

# get qid, datamodel, and splits
qidstr = '_'.join(args.qid)
data_model = getattr(sints,args.data_model)()
if args.auto_split:
    splits = np.arange(int(data_model.adf[data_model.adf['#qid']==args.qid[0]]['nsplits']))
else:
    splits = np.atleast_1d(args.split)
assert np.all(splits >= 0)

# get ivar weighting
if mm.is_root:
    ivars = []
    for i, qid in enumerate(args.qid):
        mask = simio.get_sim_mask(qid=qid, bin_apod=bin_apod, mask_version=mask_version, mask_name=mask_name)

        # check that we are using the same mask for each qid -- this is required!
        if i == 0:
            prev_mask = mask
        assert np.allclose(mask, prev_mask), "qids do not share a common mask -- this is required!"
        assert wcsutils.is_compatible(mask.wcs, prev_mask.wcs), "qids do not share a common mask wcs -- this is required!"
        prev_mask = mask

        # check for same nsplits
        nsplits = int(data_model.adf[data_model.adf['#qid']==qid]['nsplits'])
        if i == 0:
            prev_nsplits = int(data_model.adf[data_model.adf['#qid']==qid]['nsplits'])
        assert nsplits == prev_nsplits, "qids do not have common nsplits -- this is required!"

        # get the ivars and extract to mask geometry
        ivar = data_model.get_ivars(qid, calibrated=True)
        ivar = enmap.extract(ivar, mask.shape, mask.wcs)

        if args.downgrade != 1:
            mask = mask.downgrade(args.downgrade)
            ivar = ivar.downgrade(args.downgrade, op=np.sum)

        ivars.append(ivar)

    # convert to enmap -- this has shape (nmaps, nsplits, npol, ny, nx)
    ivars = enmap.enmap(ivars, wcs=mask.wcs) 

    # Get filenames of noise kernels
    fn_1d = simio.get_sim_noise_1d_fn(qidstr, downgrade=args.downgrade, smooth1d=smooth_1d, notes=args.notes,
                                        bin_apod=bin_apod, mask_version=mask_version, mask_name=mask_name)
    fn_2d = simio.get_sim_noise_tiled_2d_fn(qidstr, downgrade=args.downgrade, width_deg=width_deg,
                                            height_deg=height_deg, smoothell=delta_ell_smooth, notes=args.notes,
                                            bin_apod=bin_apod, mask_version=mask_version, mask_name=mask_name)

    # Get the noise kernels from disk
    covar_1D, flat_triu_axis_1D = enmap.read_map(fn_1d), 0
    covsqrt_2D, extra_header, extra_hdu = tnd.read_tiled_ndmap(fn_2d, extra_header=['FLAT_TRIU_AXIS'], extra_hdu=['LEDGES', 'COV1D'])
    flat_triu_axis_2D = extra_header['FLAT_TRIU_AXIS']
    ledges = extra_hdu['LEDGES']
    cov_1D = extra_hdu['COV1D']
else:
    covsqrt_2D = None
    ivars = None
    flat_triu_axis_2D = 1
    ledges = None
    cov_1D = None

# Get maps
if args.nsims is not None:
    maps = np.arange(args.nsims)
else:
    if args.maps is not None:
        assert args.maps_start is None and args.maps_end is None
        maps = np.atleast_1d(args.maps).astype(int)
    else:
        assert args.maps_start is not None and args.maps_end is not None
        maps = np.arange(args.maps_start, args.maps_end+args.maps_step, args.maps_step)

# Iterate over sims
for i, m in enumerate(maps):
    for j, split in enumerate(splits):
        if mm.is_root:
            t0 = time.time()

        # get the default (next) map_id if nsims is passed to script
        if args.nsims is not None:
            map_id = None
        else:
            map_id = m

        # Get the filename and complete the seedgen_args, if necessary
        fname, map_id = simio.get_sim_map_fn(qidstr, downgrade=args.downgrade, smooth1d=smooth_1d, width_deg=width_deg,
                                    height_deg=height_deg, smoothell=delta_ell_smooth,
                                    scale=ell_large_small_split, taper=ell_taper_width, splitnum=split, notes=args.notes,
                                    bin_apod=bin_apod, mask_version=mask_version, mask_name=mask_name, return_map_id=True, map_id=map_id)
        
        if mm.is_root:
            print(f'I am map {i*len(splits)+j+1} of {len(splits)*len(maps)} to be generated')
            print(f'I am split {split}, sim number {map_id}')

        # build a tuple for the seedgen so that each tile has an independent, repeatable seed
        seedgen_args = (split, map_id, data_model, args.qid)

        # Combine the small and large scales
        lfunc_low, lfunc_high = utils.get_ell_linear_transition_funcs(ell_large_small_split, ell_taper_width)

        if mm.is_root:
            t1 = time.time(); print(f'Init sim time: {np.round(t1-t0, 3)}')

            # Generate noise using the 1d noise and 2d noise spectra. 
            sim_1D = tn.get_iso_curvedsky_noise_sim(covar_1D, ivar=ivars, flat_triu_axis=flat_triu_axis_1D,
                                                    lfunc=lfunc_low, split=split, seedgen_args=seedgen_args)

        sim_2D = tn.get_tiled_noise_sim(covsqrt_2D, ivar=ivars, flat_triu_axis=flat_triu_axis_2D, tile_lfunc=lfunc_high,
                                                ledges=ledges, cov_1D=cov_1D, split=split, seedgen_args=seedgen_args,
                                                tiled_mpi_manager=mm)

        if mm.is_root:
            t2 = time.time(); print(f'Draw sim time: {np.round(t2-t1, 3)}')
            
            enmap.write_map(fname, sim_1D + sim_2D)

            t3 = time.time(); print(f'Save sim time: {np.round(t3-t2, 3)}')
